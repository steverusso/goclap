// generated by goclap; DO NOT EDIT

package main

import (
	"flag"
	"fmt"
	"io"
	"os"
	"reflect"
	"strconv"
)

type clapCommand struct {
	usage func() string
	opts  []clapInput
	args  []clapInput
}

type clapInput struct {
	name     string
	value    flag.Value
	required bool
}

func clapFatalf(cmdName, format string, args ...any) {
	msg := fmt.Sprintf(format, args...)
	fmt.Fprintf(os.Stderr, "error: %s.\nRun '%s -h' for usage.\n", msg, cmdName)
	os.Exit(2)
}

func (cc *clapCommand) parse(args []string) ([]string, error) {
	f := flag.FlagSet{Usage: func() {}}
	f.SetOutput(io.Discard)
	for i := range cc.opts {
		o := &cc.opts[i]
		f.Var(o.value, o.name, "")
	}

	if err := f.Parse(args); err != nil {
		if err == flag.ErrHelp {
			fmt.Println(cc.usage())
			os.Exit(0)
		}
		return nil, err
	}

	rest := f.Args()

	if len(cc.args) > 0 {
		for i := range cc.args {
			arg := &cc.args[i]
			if len(rest) <= i {
				if arg.required {
					return nil, fmt.Errorf("missing required arg '%s'", arg.name)
				}
				return nil, nil
			}
			if err := arg.value.Set(rest[i]); err != nil {
				return nil, fmt.Errorf("parsing positional argument '%s': %v", arg.name, err)
			}
		}
		return nil, nil
	}

	return rest, nil
}

type clapBool bool

func clapNewBool(p *bool) *clapBool { return (*clapBool)(p) }

func (v *clapBool) String() string { return strconv.FormatBool(bool(*v)) }

func (v *clapBool) Set(s string) error {
	b, err := strconv.ParseBool(s)
	if err != nil {
		return fmt.Errorf(`invalid boolean value "%s"`, s)
	}
	*v = clapBool(b)
	return err
}

func (*clapBool) IsBoolFlag() bool { return true }

type clapString string

func clapNewString(p *string) *clapString { return (*clapString)(p) }

func (v *clapString) String() string { return string(*v) }

func (v *clapString) Set(s string) error {
	*v = clapString(s)
	return nil
}

type clapInt[T int | int8 | int16 | int32 | int64] struct{ v *T }

func clapNewInt[T int | int8 | int16 | int32 | int64](p *T) clapInt[T] { return clapInt[T]{p} }

func (v clapInt[T]) String() string { return strconv.FormatInt(int64(*v.v), 10) }

func (v clapInt[T]) Set(s string) error {
	u64, err := strconv.ParseInt(s, 0, reflect.TypeFor[T]().Bits())
	if err != nil {
		return numError(err)
	}
	*v.v = T(u64)
	return nil
}

func numError(err error) error {
	if ne, ok := err.(*strconv.NumError); ok {
		return ne.Err
	}
	return err
}

func (*goclap) UsageHelp() string {
	return `goclap - Pre-build tool to generate command line argument parsing code from Go comments

usage:
   goclap [options]

options:
   -type  <arg>              The root command struct name
   -srcdir  <arg>            Directory of source files to parse (default ".")
   -with-version             Include goclap's version info in the generated code
   -out  <arg>               Output file path (default "./clap.gen.go")
   -usg-layout-kind  <arg>   How the usage message for each command will be structured
                             (possible values: packed or roomy)
   -usg-text-width  <arg>    Max width for lines of text in the usage message
   -version                  Print version info and exit
   -h                        Show this help message`
}

func (c *goclap) Parse(args []string) {
	p := clapCommand{
		usage: c.UsageHelp,
		opts: []clapInput{
			{name: "type", value: clapNewString(&c.rootCmdType)},
			{name: "srcdir", value: clapNewString(&c.srcDir)},
			{name: "with-version", value: clapNewBool(&c.withVersion)},
			{name: "out", value: clapNewString(&c.outFilePath)},
			{name: "usg-layout-kind", value: clapNewString(&c.usgLayoutKind)},
			{name: "usg-text-width", value: clapNewInt(&c.usgTextWidth)},
			{name: "version", value: clapNewBool(&c.version)},
		},
	}
	_, err := p.parse(args)
	if err != nil {
		clapFatalf("goclap", err.Error())
	}
}
