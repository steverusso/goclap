// Code generated by goclap; DO NOT EDIT
package main

import (
	"fmt"
	"os"
	"strings"
)

func claperr(format string, a ...any) {
	format = "\033[1;31merror:\033[0m " + format
	fmt.Fprintf(os.Stderr, format, a...)
}

type clapUsagePrinter interface {
	printUsage(to *os.File)
}

func exitUsgGood(u clapUsagePrinter) {
	u.printUsage(os.Stdout)
	os.Exit(0)
}

func clapParseBool(s string) bool {
	if s == "" || s == "true" {
		return true
	}
	if s != "false" {
		claperr("invalid boolean value '%s'\n", s)
		os.Exit(1)
	}
	return false
}

func optParts(arg string) (string, string, bool) {
	if arg == "-" {
		claperr("emtpy option ('-') found\n")
		os.Exit(1)
	}
	if arg[0] == '-' {
		arg = arg[1:]
	}
	if arg[0] == '-' {
		arg = arg[1:]
	}
	if eqIdx := strings.IndexByte(arg, '='); eqIdx != -1 {
		name := arg[:eqIdx]
		eqVal := ""
		if eqIdx < len(arg) {
			eqVal = arg[eqIdx+1:]
		}
		return name, eqVal, true
	}
	return arg, "", false
}

func (*goclap) printUsage(to *os.File) {
	fmt.Fprintf(to, `%[1]s - pre-build tool to generate command line argument parsing code from Go comments

usage:
   %[1]s [options]

options:
   -v, --version           print version info and exit
       --include-version   include the version info in the generated code
       --type  <arg>       the root command struct name
       --srcdir  <arg>     directory of source files to parse (default ".")
   -o, --out  <arg>        output file path (default "./clap.go")
   -h, --help              show this help message
`, os.Args[0])
}

func (c *goclap) parse(args []string) {
	if len(args) > 0 && len(args) == len(os.Args) {
		args = args[1:]
	}
	var i int
	for ; i < len(args); i++ {
		if args[i][0] != '-' {
			break
		}
		if args[i] == "--" {
			i++
			break
		}
		k, eqv, hasEq := optParts(args[i][1:])

		switch k {
		case "version", "v":
			c.version = clapParseBool(eqv)
		case "include-version":
			c.incVersion = clapParseBool(eqv)
		case "type":
			if hasEq {
				c.rootCmdType = eqv
			} else if i == len(args)-1 {
				claperr("string option '%s' needs an argument\n", k)
				os.Exit(1)
			} else {
				i++
				c.rootCmdType = args[i]
			}
		case "srcdir":
			if hasEq {
				c.srcDir = eqv
			} else if i == len(args)-1 {
				claperr("string option '%s' needs an argument\n", k)
				os.Exit(1)
			} else {
				i++
				c.srcDir = args[i]
			}
		case "out", "o":
			if hasEq {
				c.outFilePath = eqv
			} else if i == len(args)-1 {
				claperr("string option '%s' needs an argument\n", k)
				os.Exit(1)
			} else {
				i++
				c.outFilePath = args[i]
			}
		case "help", "h":
			exitUsgGood(c)
		default:
			claperr("unknown option '%s'\n", k)
			os.Exit(1)
		}
	}
}
