// generated by goclap{{ with .Version }} ({{ . }}){{ end }}; DO NOT EDIT

package {{ .PkgName }}

import (
	{{- if .HasSubcmds }}
	"errors"{{ end }}
	"flag"
	"fmt"
	"io"
	"os"
	{{- if or .HasNumber }}
	"reflect"{{ end }}
	{{- if or .HasNumber .HasBool }}
	"strconv"{{ end }}
)

type clapCommand struct {
	usage func() string
	opts  []clapInput
	args  []clapInput
	{{- if .HasSubcmds }}
	cmds  []string{{ end }}
}

type clapInput struct {
	name     string
	{{- if .NeedsEnvCode }}
	envName  string{{ end }}
	value    flag.Value
	required bool
}

{{- if .NeedsEnvCode }}

func (in *clapInput) parseEnv() error {
	if in.envName == "" {
		return nil
	}
	s, ok := os.LookupEnv(in.envName)
	if !ok {
		return nil
	}
	if err := in.value.Set(s); err != nil {
		return fmt.Errorf("parsing env var '%s': %w", in.envName, err)
	}
	return nil
}
{{- end }}

func clapFatalf(cmdName, format string, args ...any) {
	msg := fmt.Sprintf(format, args...)
	fmt.Fprintf(os.Stderr, "error: %s.\nRun '%s -h' for usage.\n", msg, cmdName)
	os.Exit(2)
}

func (cc *clapCommand) parse(args []string) ([]string, error) {
	f := flag.FlagSet{Usage: func() {}}
	f.SetOutput(io.Discard)
	for i := range cc.opts {
		o := &cc.opts[i]
		{{- if .NeedsEnvCode }}
		if err := o.parseEnv(); err != nil {
			return nil, err
		}
		{{- end }}
		f.Var(o.value, o.name, "")
	}

	if err := f.Parse(args); err != nil {
		if err == flag.ErrHelp {
			fmt.Println(cc.usage())
			os.Exit(0)
		}
		return nil, err
	}

	{{- /* TODO(steve): check for missing required flags when supported*/}}

	rest := f.Args()

	if len(cc.args) > 0 {
		{{- if .NeedsEnvCode }}
		for i := range cc.args {
			arg := &cc.args[i]
			if err := arg.parseEnv(); err != nil {
				return nil, err
			}
		}
		{{- end }}
		for i := range cc.args {
			arg := &cc.args[i]
			if len(rest) <= i {
				if arg.required {
					return nil, fmt.Errorf("missing required arg '%s'", arg.name)
				}
				return nil, nil
			}
			if err := arg.value.Set(rest[i]); err != nil {
				return nil, fmt.Errorf("parsing positional argument '%s': %v", arg.name, err)
			}
		}
		return nil, nil
	}

	{{- if .HasSubcmds }}

	if len(cc.cmds) > 0 {
		if len(rest) == 0 {
			return rest, errors.New("no subcommand provided")
		}
		for i := range cc.cmds {
			if rest[0] == cc.cmds[i] {
				return rest, nil
			}
		}
		return rest, fmt.Errorf("unknown subcommand '%s'", rest[0])
	}
	{{- end }}

	return rest, nil
}

{{- if .Types.HasAny "bool" }}

type clapBool bool

func clapNewBool(p *bool) *clapBool { return (*clapBool)(p) }

func (v *clapBool) String() string { return strconv.FormatBool(bool(*v)) }

func (v *clapBool) Set(s string) error {
	b, err := strconv.ParseBool(s)
	if err != nil {
		return fmt.Errorf(`invalid boolean value "%s"`, s)
	}
	*v = clapBool(b)
	return err
}

func (*clapBool) IsBoolFlag() bool { return true }
{{- end }}

{{- if .Types.HasAny "string" }}

type clapString string

func clapNewString(p *string) *clapString { return (*clapString)(p) }

func (v *clapString) String() string { return string(*v) }

func (v *clapString) Set(s string) error {
	*v = clapString(s)
	return nil
}
{{- end }}

{{- if .HasFloat }}

type clapFloat[T float32 | float64] struct{ v *T }

func clapNewFloat[T float32 | float64](p *T) clapFloat[T] { return clapFloat[T]{p} }

func (v clapFloat[T]) String() string {
	return strconv.FormatFloat(float64(*v.v), 'g', -1, reflect.TypeFor[T]().Bits())
}

func (v clapFloat[T]) Set(s string) error {
	f64, err := strconv.ParseFloat(s, reflect.TypeFor[T]().Bits())
	if err != nil {
		return numError(err)
	}
	*v.v = T(f64)
	return err
}
{{- end }}

{{- if .HasInt }}

type clapInt[T int | int8 | int16 | int32 | int64] struct{ v *T }

func clapNewInt[T int | int8 | int16 | int32 | int64](p *T) clapInt[T] { return clapInt[T]{p} }

func (v clapInt[T]) String() string { return strconv.FormatInt(int64(*v.v), 10) }

func (v clapInt[T]) Set(s string) error {
	u64, err := strconv.ParseInt(s, 0, reflect.TypeFor[T]().Bits())
	if err != nil {
		return numError(err)
	}
	*v.v = T(u64)
	return nil
}
{{- end }}

{{- if .HasUint }}

type clapUint[T uint | uint8 | uint16 | uint32 | uint64] struct{ v *T }

func clapNewUint[T uint | uint8 | uint16 | uint32 | uint64](p *T) clapUint[T] { return clapUint[T]{p} }

func (v clapUint[T]) String() string { return strconv.FormatUint(uint64(*v.v), 10) }

func (v clapUint[T]) Set(s string) error {
	u64, err := strconv.ParseUint(s, 0, reflect.TypeFor[T]().Bits())
	if err != nil {
		return numError(err)
	}
	*v.v = T(u64)
	return nil
}
{{- end }}

{{- if .HasNumber }}

func numError(err error) error {
	if ne, ok := err.(*strconv.NumError); ok {
		return ne.Err
	}
	return err
}
{{- end }}
