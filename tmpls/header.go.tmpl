// generated by goclap{{ if .IncVersion }} ({{ .Version }}){{ end }}; DO NOT EDIT

package {{ .PkgName }}

import (
	{{- with .Types }}{{ if or .HasInt .HasUint .HasFloat }}
	"errors"{{ end }}{{ end }}
	"fmt"
	"os"
	{{- with .Types }}{{ if or .HasInt .HasUint .HasFloat }}
	"strconv"{{ end }}{{ end }}
	"strings"
)

func claperr(format string, a ...any) {
	format = "\033[1;31merror:\033[0m " + format
	fmt.Fprintf(os.Stderr, format, a...)
}

type clapper struct {
	usg  func(to *os.File)
	args []string
	idx  int

{{- if .RootCmd.HasEnvArgOrOptSomewhere }}

	envName string
	envVal  string
{{- end }}

	optName  string
	optEqVal string
	optHasEq bool
}

func (z *clapper) exitUsgGood() {
	z.usg(os.Stdout)
	os.Exit(0)
}

{{- if .RootCmd.HasReqArgSomewhere }}

func (z *clapper) exitMissingArg(name string) {
	claperr("not enough args: no \033[1;33m%s\033[0m provided\n", name)
	z.usg(os.Stderr)
	os.Exit(1)
}
{{- end }}

{{- if .RootCmd.HasSubcmds }}

func (z *clapper) exitUnknownCmd(name string) {
	claperr("unknown command '%s'\n", name)
	z.usg(os.Stderr)
	os.Exit(1)
}
{{- end }}

{{- if .RootCmd.HasEnvArgOrOptSomewhere }}

func (z *clapper) stageEnv(name string) (ok bool) {
	z.envName = name
	z.envVal, ok = os.LookupEnv(name)
	return ok
}
{{- end }}

func (z *clapper) stageOpt() bool {
	if z.optName != "" {
		z.idx++
	}
	if z.idx > len(z.args)-1 {
		z.optName = ""
		return false
	}
	arg := z.args[z.idx]
	if arg[0] != '-' {
		z.optName = ""
		return false
	}
	arg = arg[1:]
	if arg == "" {
		claperr("emtpy option ('-') found\n")
		os.Exit(1)
	}
	if arg[0] == '-' {
		arg = arg[1:]
	}
	if arg == "" {
		z.idx++
		z.optName = ""
		return false
	}

	z.optEqVal = ""
	if eqIdx := strings.IndexByte(arg, '='); eqIdx != -1 {
		z.optName = arg[:eqIdx]
		if eqIdx < len(arg) {
			z.optEqVal = arg[eqIdx+1:]
		}
		z.optHasEq = true
	} else {
		z.optName = arg
		z.optHasEq = false
	}
	return true
}

func (z *clapper) nextStr() string {
{{- if .RootCmd.HasEnvArgOrOptSomewhere }}
	if z.envName != "" {
		return z.envVal
	}
{{- end }}
	if z.optName != "" {
		if z.optHasEq {
			return z.optEqVal
		}
		if z.idx == len(z.args)-1 {
			claperr("option '%s' needs an argument\n", z.optName)
			os.Exit(1)
		}
		z.idx++
		return z.args[z.idx]
	}
	z.idx++
	return z.args[z.idx-1]
}

{{- if or .Types.HasBool .Types.HasInt .Types.HasUint .Types.HasFloat }}

func (z *clapper) exitBadInput(typ string, err error) {
	var forWhat string
	switch {
	case z.optName != "":
		forWhat = "option '" + z.optName + "'"
	{{- if .RootCmd.HasEnvArgOrOptSomewhere }}
	case z.envName != "":
		forWhat = "env var '" + z.envName + "'"{{ end }}
	default:
		forWhat = "argument"
	}
	claperr("invalid %s for %s: %v\n", typ, forWhat, err)
	os.Exit(1)
}
{{- end }}

{{- if .Types.HasAny "bool" }}

func (z *clapper) thisBool() bool {
	{{ if .RootCmd.HasEnvArgOrOptSomewhere }}var s string
	if z.envName != "" {
		s = z.envVal
	} else {
		s = z.optEqVal
	}{{ else }}s := z.optEqVal{{ end }}
	if s == "" || s == "true" || s == "1" {
		return true
	}
	if s != "false" && s != "0" {
		z.exitBadInput("bool", fmt.Errorf("%q not recognized as a boolean", s))
	}
	return false
}
{{- end }}

{{- if .Types.HasAny "int" }}

func (z *clapper) nextInt() int {
	u64, err := strconv.ParseInt(z.nextStr(), 10, 0)
	if err != nil {
		z.exitBadInput("int", errors.Unwrap(err))
	}
	return int(u64)
}
{{- end }}

{{- if .Types.HasAny "int8" }}

func (z *clapper) nextInt8() int8 {
	u64, err := strconv.ParseInt(z.nextStr(), 10, 8)
	if err != nil {
		z.exitBadInput("int8", errors.Unwrap(err))
	}
	return int8(u64)
}
{{- end }}

{{- if .Types.HasAny "int16" }}

func (z *clapper) nextInt16() int16 {
	u64, err := strconv.ParseInt(z.nextStr(), 10, 16)
	if err != nil {
		z.exitBadInput("int16", errors.Unwrap(err))
	}
	return int16(u64)
}
{{- end }}

{{- if .Types.HasAny "int32" "rune" }}

func (z *clapper) nextInt32() int32 {
	u64, err := strconv.ParseInt(z.nextStr(), 10, 32)
	if err != nil {
		z.exitBadInput("int32", errors.Unwrap(err))
	}
	return int32(u64)
}
{{- end }}

{{- if .Types.HasAny "int64" }}

func (z *clapper) nextInt64() int64 {
	u64, err := strconv.ParseInt(z.nextStr(), 10, 64)
	if err != nil {
		z.exitBadInput("int64", errors.Unwrap(err))
	}
	return u64
}
{{- end }}

{{- if .Types.HasAny "uint" }}

func (z *clapper) nextUint() uint {
	u64, err := strconv.ParseUint(z.nextStr(), 10, 0)
	if err != nil {
		z.exitBadInput("uint", errors.Unwrap(err))
	}
	return uint(u64)
}
{{- end }}

{{- if .Types.HasAny "uint8" "byte" }}

func (z *clapper) nextUint8() uint8 {
	u64, err := strconv.ParseUint(z.nextStr(), 10, 8)
	if err != nil {
		z.exitBadInput("uint8", errors.Unwrap(err))
	}
	return uint8(u64)
}
{{- end }}

{{- if .Types.HasAny "uint16" }}

func (z *clapper) nextUint16() uint16 {
	u64, err := strconv.ParseUint(z.nextStr(), 10, 16)
	if err != nil {
		z.exitBadInput("uint16", errors.Unwrap(err))
	}
	return uint16(u64)
}
{{- end }}

{{- if .Types.HasAny "uint32" }}

func (z *clapper) nextUint32() uint32 {
	u64, err := strconv.ParseUint(z.nextStr(), 10, 32)
	if err != nil {
		z.exitBadInput("uint32", errors.Unwrap(err))
	}
	return uint32(u64)
}
{{- end }}

{{- if .Types.HasAny "uint64" }}

func (z *clapper) nextUint64() uint64 {
	u64, err := strconv.ParseUint(z.nextStr(), 10, 64)
	if err != nil {
		z.exitBadInput("uint64", errors.Unwrap(err))
	}
	return u64
}
{{- end }}

{{- if .Types.HasAny "float32" }}

func (z *clapper) nextFloat32() float32 {
	f64, err := strconv.ParseFloat(z.nextStr(), 32)
	if err != nil {
		z.exitBadInput("float32", errors.Unwrap(err))
	}
	return float32(f64)
}
{{- end }}

{{- if .Types.HasAny "float64" }}

func (z *clapper) nextFloat64() float64 {
	f64, err := strconv.ParseFloat(z.nextStr(), 64)
	if err != nil {
		z.exitBadInput("float64", errors.Unwrap(err))
	}
	return f64
}
{{- end }}
