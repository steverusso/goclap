// generated by goclap{{ if .IncVersion }} ({{ .Version }}){{ end }}; DO NOT EDIT

package {{ .PkgName }}

import (
	"fmt"
	"os"
	"strconv"
	"strings"
)

func claperr(format string, a ...any) {
	format = "\033[1;31merror:\033[0m " + format
	fmt.Fprintf(os.Stderr, format, a...)
}

type clapUsagePrinter interface {
	printUsage(to *os.File)
}

{{- if .RootCmd.HasEnvArgOrOptSomewhere }}

func clapSetEnv(name string, v any) {
	ev, ok := os.LookupEnv(name)
	if !ok {
		return
	}
	if b, ok := v.(*bool); ok {
		*b = (ev != "false" && ev != "0")
		return
	}
	err := clapParseInto(v, ev)
	if err != nil {
		claperr("invalid argument for env var '%s': %v\n", name, err)
		os.Exit(1)
	}
}
{{- end }}

{{- if .RootCmd.HasReqArgSomewhere }}

func exitMissingArg(u clapUsagePrinter, name string) {
	claperr("not enough args: no \033[1;33m%s\033[0m provided\n", name)
	u.printUsage(os.Stderr)
	os.Exit(1)
}
{{- end }}

{{- if .RootCmd.HasSubcmds }}

func (z *clapper) exitUnknownCmd(name string) {
	claperr("unknown command '%s'\n", name)
	z.cmd.printUsage(os.Stderr)
	os.Exit(1)
}
{{- end }}

func optParts(arg string) (string, string, bool) {
	if arg == "-" {
		claperr("emtpy option ('-') found\n")
		os.Exit(1)
	}
	if arg[0] == '-' {
		arg = arg[1:]
	}
	if arg[0] == '-' {
		arg = arg[1:]
	}
	if eqIdx := strings.IndexByte(arg, '='); eqIdx != -1 {
		name := arg[:eqIdx]
		eqVal := ""
		if eqIdx < len(arg) {
			eqVal = arg[eqIdx+1:]
		}
		return name, eqVal, true
	}
	return arg, "", false
}

type clapper struct {
	cmd      clapUsagePrinter
	args     []string
	idx      int
	skip     bool
	optsDone bool

	curr struct {
		key   string
		eqVal string
		hasEq bool
	}
}

func (c *clapper) exitUsgGood() {
	c.cmd.printUsage(os.Stdout)
	os.Exit(0)
}

func (c *clapper) nextOpt() bool {
	if c.skip {
		c.idx++
	}
	if c.args[c.idx][0] != '-' {
		c.optsDone = true
		return false
	}
	if c.args[c.idx] == "--" {
		c.idx++
		c.optsDone = true
		return false
	}
	c.curr.key, c.curr.eqVal, c.curr.hasEq = optParts(c.args[c.idx])
	c.skip = false
	return true
}

func (c *clapper) val() string {
	if c.optsDone {
		s := c.args[c.idx]
		c.idx++
		return s
	}
	if c.curr.hasEq {
		return c.curr.eqVal
	}
	c.skip = true
	if c.idx == len(c.args)-1 {
		claperr("option '%s' needs an argument\n", c.curr.key)
		os.Exit(1)
	}
	return c.args[c.idx+1]
}

func (c *clapper) pBool() bool {
	s := c.curr.eqVal
	if s == "" || s == "true" {
		return true
	}
	if s != "false" {
		claperr("invalid boolean value '%s'\n", s)
		os.Exit(1)
	}
	return false
}

{{- if .Types.HasInt }}

func (c *clapper) pInt(bs int) int64 {
	i64, err := strconv.ParseInt(c.val(), 10, bs)
	if err != nil {
		claperr("invalid argument for '%s': %v\n", c.curr.key, err)
		os.Exit(1)
	}
	return i64
}
{{- end }}

{{- if .Types.HasUint }}

func (c *clapper) pUint(bs int) uint64 {
	u64, err := strconv.ParseUint(c.val(), 10, bs)
	if err != nil {
		claperr("invalid argument for '%s': %v\n", c.curr.key, err)
		os.Exit(1)
	}
	return u64
}
{{- end }}

{{- if .Types.HasFloat }}

func (c *clapper) pFloat(bs int) float64 {
	f64, err := strconv.ParseFloat(c.val(), bs)
	if err != nil {
		claperr("invalid argument for '%s': %v\n", c.curr.key, err)
		os.Exit(1)
	}
	return f64
}
{{- end }}

func clapParseInto(v any, s string) error {
	if v, ok := v.(*string); ok {
		*v = s
		return nil
	}
	var (
		i64 int64
		u64 uint64
		err error
	)
	switch v := v.(type) {
	case *int:
		i64, err = strconv.ParseInt(s, 10, 0)
		*v = int(i64)
	case *int8:
		i64, err = strconv.ParseInt(s, 10, 8)
		*v = int8(i64)
	case *int16:
		i64, err = strconv.ParseInt(s, 10, 16)
		*v = int16(i64)
	case *int32:
		i64, err = strconv.ParseInt(s, 10, 32)
		*v = int32(i64)
	case *int64:
		*v, err = strconv.ParseInt(s, 10, 64)
	case *uint:
		u64, err = strconv.ParseUint(s, 10, 0)
		*v = uint(u64)
	case *uint8:
		u64, err = strconv.ParseUint(s, 10, 8)
		*v = uint8(u64)
	case *uint16:
		u64, err = strconv.ParseUint(s, 10, 16)
		*v = uint16(u64)
	case *uint32:
		u64, err = strconv.ParseUint(s, 10, 32)
		*v = uint32(u64)
	case *uint64:
		*v, err = strconv.ParseUint(s, 10, 64)
	case *uintptr:
		u64, err = strconv.ParseUint(s, 10, 64)
		*v = uintptr(u64)
	case *float32:
		var f float64
		f, err = strconv.ParseFloat(s, 32)
		*v = float32(f)
	case *float64:
		*v, err = strconv.ParseFloat(s, 64)
	}
	return err
}
