
func (c *{{ .TypeName }}) parse(args []string) {
	{{- /* Drop the program name from args if it's there. */ -}}
	{{ if .IsRoot }}
	if len(args) > 0 && len(args) == len(os.Args) {
		args = args[1:]
	}
	{{- end }}

	cc := clap.NewCommand("{{ .Parents }}{{ .UsgName }}")

	{{- range .Opts }}
		{{- if ne .Name "h" }}
	cc.Flag("{{ .Name }}", clap.New{{ .FieldType.ClapValueType }}(&c.{{ .FieldName }}))
		{{- with .EnvVar }}.Env("{{ . }}"){{ end }}
		{{- end }}
	{{- end }}

	{{- /* Arguments. */ -}}
	{{- with .Args }}
		{{- range $i, $arg := . }}
	cc.Arg("{{ $arg.UsgName }}", clap.New{{ .FieldType.ClapValueType }}(&c.{{ .FieldName }}))
		{{- with .EnvVar }}.Env("{{ . }}"){{ end }}
		{{- if $arg.IsRequired }}.Require(){{ end }}
		{{- end -}}
	{{- end }}
	cc.Parse(args, c.usage)

	{{- /* Subcommands. */ -}}
	{{- with .Subcmds }}

	rest := f.Args()
	if len(rest) == 0 {
		fmt.Fprintf(os.Stderr, "error: no subcommand provided\nRun '{{ $.Parents }}{{ $.UsgName }} -h' for usage.\n")
		os.Exit(2)
	}
	switch rest[0] {
	{{- range . }}
	case {{ .QuotedNames }}:
		c.{{ .FieldName }} = &{{ .TypeName }}{}
		c.{{ .FieldName }}.parse(rest[1:])
	{{- end }}
	default:
		fmt.Fprintf(os.Stderr, "error: unknown subcommand '%s'\nRun '{{ $.Parents }}{{ $.UsgName }} -h' for usage.\n", rest[0])
		os.Exit(2)
	}
	{{- end }}
}
