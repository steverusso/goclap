
func (c *{{ .TypeName }}) parse(args []string) {
	{{- /* Drop the program name from args if it's there. */ -}}
	{{ if .IsRoot }}
	if len(args) > 0 && len(args) == len(os.Args) {
		args = args[1:]
	}
	{{- end }}
	z := clapper{usg: c.printUsage, args: args}
	{{- /* Parse environment variables. */}}
	{{- with .EnvVals }}
	{{- range . }}
	if z.stageEnv("{{ .VarName }}") {
		c.{{ .FieldName }} = z.{{ .FieldType.ClapperMethodName }}()
	}
	{{- end }}
	z.envName, z.envVal = "", ""
	{{- end }}

	{{- /* Parse options. */}}
	for z.stageOpt() {
		switch z.optName {
	{{- range .Opts }}
		case {{ .QuotedPlainNames }}:
		{{- if eq .Long "help" }}
			z.exitUsgGood()
			{{- continue }}
		{{- end }}
			c.{{ .FieldName }} = z.{{ .FieldType.ClapperMethodName }}()
	{{- end }}
		default:
			claperr("unknown option '%s'\n", z.optName)
			os.Exit(1)
		}
	}

	{{- /* Arguments. */ -}}
	{{- if .HasArgs }}
	args = args[z.idx:]

		{{- /* Add error handling for missing arguments that are required. */ -}}
		{{- range $i, $arg := .RequiredArgs }}
	if len(args) < {{ add $i 1 }} {
		z.exitMissingArg("{{ $arg.UsgName }}")
	}
		{{- end -}}

		{{- range $i, $arg := .Args }}

			{{- if not $arg.IsRequired }}
	if len(args) < {{ add $i 1 }} {
		return
	}
			{{- end }}

	c.{{ .FieldName }} = z.{{ .FieldType.ClapperMethodName }}()

		{{- end -}}{{- /* range all args */ -}}
	{{- end }}{{- /* if args */ -}}

	{{- /* Subcommands. */ -}}
	{{- if .HasSubcmds }}
	if z.idx >= len(args) {
		c.printUsage(os.Stderr)
		os.Exit(1)
	}
	switch args[z.idx] {
	{{- range .Subcmds }}
	case {{ .QuotedNames }}:
		c.{{ .FieldName }} = new({{ .TypeName }})
		c.{{ .FieldName }}.parse(args[z.idx+1:])
	{{- end }}
	default:
		z.exitUnknownCmd(args[z.idx])
	}
	{{- end }}
}
